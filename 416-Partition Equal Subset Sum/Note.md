# 416. Partition Equal Subset Sum

Given an integer array `nums`, 
return `true` if you can partition the array into two subsets such that 
the sum of the elements in both subsets is equal or `false` otherwise.

**Constraints:**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

## 基礎思路

這道題目要求將一個數字陣列拆成兩個子集，使得兩個子集的元素總和相同。
我們首先分析問題的核心特性：

- **若總和為奇數**，則不可能分為兩個相等的子集。
- **若總和為偶數**，則問題轉化為：「能否找到一個子集，其元素總和為所有元素總和的一半？」

### 範例解析

Input: `nums = [1, 5, 11, 5]`：

- 總和為 `1 + 5 + 11 + 5 = 22`，偶數，因此目標子集和為 `22 / 2 = 11`。
- 接下來問題轉化成：「能否從陣列中挑選一些元素使其和為 11？」

我們使用 **位元操作 (Bit Operation)** 的動態規劃方法：

- 建立一個 BigInt 類型的位元遮罩（bitmask），透過每一個 bit 位置記錄「是否能夠達成對應的子集和」。
- 位元遮罩的第 `i` 位如果為 1，表示存在一個子集，其總和為 `i`。

以 `nums = [1, 5, 11, 5]` 為例，初始狀態為：
```
dp = 1 (表示只有0這個和是達成的, 即二進位: ...00001)
```

逐步加入元素後：

- 加入元素 `1`：
    - 將目前的位元遮罩左移 1 位（表示現有子集和加上元素 1）：
  ```
  原本:   00000001 (0)
  左移1:  00000010 (1)
  OR後:   00000011 (0,1)
  ```
  表示目前能達成的和為 {0, 1}

- 加入元素 `5`：
    - 將位元遮罩左移 5 位：
  ```
  原本:      00000011 (0,1)
  左移5位:   01100000 (5,6)
  OR後:      01100011 (0,1,5,6)
  ```
  表示目前能達成的和為 {0, 1, 5, 6}

- 加入元素 `11`：
    - 將位元遮罩左移 11 位：
  ```
  原本:              01100011 (0,1,5,6)
  左移11位:  1100011000000000 (11,12,16,17)
  OR後:     1100011001100011 (0,1,5,6,11,12,16,17)
  ```
  目前能達成的和為 {0,1,5,6,11,12,16,17}，已經包括我們的目標和 `11`。

- 最後加入元素 `5`：
    - 將位元遮罩左移 5 位：
  ```
  原本:          1100011001100011
  左移5位:  110001100110001100000
  OR後:     110011101110011100011
  ```
  最終遮罩代表更多可能的子集和，但因為我們之前已經達成目標和（11），後續只是更多可能性的補充。

由此範例可以看出，透過位元操作可以有效記錄所有可能的子集和，最終只要檢查目標子集和（11）是否能達成即可。

## 解題步驟

### Step 1：計算數組總和與奇偶性檢查

首先，利用 `reduce` 函數計算陣列 `nums` 的所有元素之和。若總和為奇數，則不可能將陣列分成兩個和相等的子集，故直接返回 `false`。

```typescript
const sum = nums.reduce((a, b) => a + b, 0);
if (sum % 2 !== 0) {
  return false;
}
```

### Step 2：確定目標子集和

當總和為偶數時，我們設定目標子集和 `target` 為 `sum / 2`。接下來的問題就轉化為「是否存在一個子集，其和為 target」。

```typescript
const target = sum / 2;
```

### Step 3：初始化 BigInt 位元遮罩 dp

使用 BigInt 初始化 `dp` 為 `1n`。這表示在初始狀態下，只有和為 0 是可達成的（因為二進位表示中只有第 0 位是 1）。

```typescript
let dp = 1n;
```

### Step 4：更新 dp 達成所有可能的子集和

遍歷數組中每一個數字，對於每個數 `num`，透過 `dp << BigInt(num)` 將原先能達成的所有子集和向左移動 `num` 位，代表原有和加上 `num` 後的新可能。接著用位元 OR 操作符 `|=` 將新狀態與原狀態合併，這樣 `dp` 中所有被置位的位元就代表所有可能達成的子集和。

```typescript
for (const num of nums) {
  dp |= dp << BigInt(num);
}
```

### Step 5：檢查目標子集和是否存在

最後，通過將 `dp` 右移 `target` 位，並利用位元 AND 操作取最低位，來檢查目標和是否在可能達成的子集和中出現。如果結果為 `1n`，代表存在一個子集的和等於 `target`，因此可以分成兩個和相等的子集，返回 `true`；否則返回 `false`。

```typescript
return ((dp >> BigInt(target)) & 1n) === 1n;
```

## 時間複雜度

- **位元動態規劃更新**：對陣列中每個元素都進行一次位元左移與 OR 操作，時間複雜度主要取決於陣列長度與每次位移操作的位數。在最壞情況下，時間複雜度大約為 $O(n \times target)$。
- 總時間複雜度為 $O(n \times target)$。

> $O(n \times target)$

## 空間複雜度

- **BigInt 位元遮罩**：使用 BigInt 儲存所有可能的子集和，所需的空間主要取決於 `target` 的大小，因此空間複雜度為 $O(target)$。
- 總空間複雜度為 $O(target)$。

> $O(target)$
